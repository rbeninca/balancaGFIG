<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Balan√ßa GFIG - Modo Minimalista</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preload" href="estilo.css" as="style">
  <link rel="stylesheet" href="estilo.css">
  <link rel="stylesheet" href="usb_warning.css">
  <link rel="stylesheet" href="gravacoes.css">
  <script src="apexcharts" defer></script>
  <script src="wizard_simplificado.js" defer></script>
  <script src="notification.js" defer></script>
  <script src="usb_warning.js" defer></script>
  <script src="gravacoes.js" defer></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      /*fonte monom√©trica para melhor legibilidade de n√∫meros*/
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      /*      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif; --- IGNORE --- */
      background: #ffffff;
      color: #000000;
      /* Removed overflow: hidden; to allow scrolling */
      min-height: 100vh; /* Changed height to min-height to allow content to expand */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* Changed to flex-start to align content from the top */
      padding-bottom: 80px; /* Add padding for the fixed footer */
    }

    /* Container Principal */
    .container {
      width: 100%;
      max-width: 900px;
      padding: 1rem;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      
    }

    /* Adjustments for smaller screens */
    @media (max-width: 768px) {
      .container {
        gap: 1.5rem; /* Reduced gap for mobile */
        padding: 1rem; /* Reduced padding for mobile */
      }

      .chart-container {
        height: 35vh; /* Reduced chart height for mobile */
        margin-top: 1rem; /* Reduced margin for mobile */
      }

      .actions {
        margin-top: 0.5rem; /* Further reduced margin for buttons */
      }
    }

    /* Logo/T√≠tulo */
    .header {
      opacity: 0.6;
      transition: opacity 0.3s;
    }

    .header:hover {
      opacity: 1;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.5px;
    }

    /* Leitura Principal */
    .reading-container {
      position: relative;
    }

    .reading {
      font-size: 8rem;
      font-weight: 200;
      line-height: 1;
      letter-spacing: -0.02em;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      color: #000000;
      position: relative;
      text-align: right;
      display: inline-block;
    }

    /* Garante que o valor da leitura mantenha o tamanho da fonte */
    #readingValue {
      font-size: inherit;
      font-weight: inherit;
      line-height: inherit;
    }

    .reading.negative::before {
      content: '‚àí';
      position: absolute;
      left: -1.2em;
      top: 0;
      font-size: 1em;
      color: inherit;
    }

    .reading.positive {
      color: #000000;
    }

    .reading.negative {
      color: #888888;
    }

    .unit {
      font-size: 6.5rem;
      font-weight: 300;
      margin-left: 0.5rem;
      opacity: 0.7;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 8px;
    }

    .unit:hover {
      opacity: 1;
      transform: scale(1.05);
      background: rgba(0, 0, 0, 0.05);
    }

    .unit:active {
      transform: scale(0.95);
    }

    /* Estilos para d√≠gitos de precis√£o */
    .digit-reliable {
      color: inherit;
      font-weight: inherit;
    }

    .digit-unreliable {
      color: #aaaaaa;
      opacity: 0.6;
      font-weight: 300;
    }

    .accuracy-indicator {
      font-size: 0.7rem;
      color: #999;
      margin-top: 4px;
      text-align: center;
      font-weight: 300;
      letter-spacing: 0.5px;
    }

    .accuracy-indicator span {
      color: #aaaaaa;
    }

    .decimal-controls {
      display: flex;
      flex-direction: row;
      gap: 0.3rem;
      margin-left: 1rem;
      align-items: center;
      justify-content: center;
    }

    .decimal-btn {
      width: 2.8rem;
      height: 2.5rem;
      font-size: 0.75rem;
      font-weight: 300;
      border: 1px solid #d0d0d0;
      background: #fafafa;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
    }

    .decimal-btn:hover {
      background: #f0f0f0;
      border-color: #bbb;
      color: #666;
    }

    .decimal-btn:active {
      background: #e5e5e5;
      transform: scale(0.95);
    }

    .decimal-display {
      font-size: 0.9rem;
      font-weight: 400;
      color: #aaa;
      min-width: 1.5rem;
      text-align: center;
    }

    /* Transi√ß√µes suaves para mudan√ßa de cor */
    #readingValue {
      transition: color 0.4s ease-in-out;
    }

    /* Gr√°fico */
    .chart-container {
      width: calc(100vw - 20px);
      height: 45vh;
      position: relative;
      margin-top: 1.5rem;
      margin-left: 10px;
      margin-right: 10px;
      display: flex;
    }

    #minimalChart {
      flex: 1;
      height: 100%;
      max-width: calc(100% - 65px);
    }

    /* Barra de Range Vertical */
    .range-control {
      width: 60px;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
      background: transparent;
      border: none;
    }

    .range-toggle {
      font-size: 1rem;
      color: #666;
      padding: 4px 8px;
      cursor: pointer;
      user-select: none;
      transition: color 0.2s;
      text-align: center;
      border-radius: 4px;
      position: absolute;
      top: -30px;
      z-index: 10;
    }

    .range-toggle:hover {
      color: #000;
      background: rgba(0, 0, 0, 0.05);
    }

    .range-toggle.active {
      color: #0066ff;
      font-weight: 500;
    }

    .range-scale {
      flex: 1;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 0 10px;
      position: relative;
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .range-tick {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      position: relative;
      height: 0;
    }

    .range-tick-line {
      width: 8px;
      height: 1px;
      background: #d0d0d0;
      margin-left: 4px;
    }

    .range-tick-value {
      font-size: 0.6rem;
      color: #666;
      min-width: 35px;
      text-align: right;
      display: none;
    }

    .range-bar {
      position: absolute;
      right: 18px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #d0d0d0;
    }

    .range-indicator {
      position: absolute;
      right: 16px;
      width: 6px;
      height: 6px;
      background: #0066ff;
      border-radius: 50%;
      transform: translateY(-50%);
      transition: top 0.2s ease-out, width 0.3s, height 0.3s, right 0.3s;
    }

    .range-indicator.auto-mode {
      width: 10px;
      height: 10px;
      right: 14px;
      box-shadow: 0 0 8px rgba(0, 102, 255, 0.5);
    }

    .range-slider {
      position: absolute;
      right: -5px;
      top: 0;
      bottom: 0;
      width: 30px;
      cursor: pointer;
    }

    .range-handle {
      position: absolute;
      right: -13px;
      width: 24px;
      height: 24px;
      background: #ffffff;
      border: 2px solid #0066ff;
      border-radius: 4px;
      cursor: ns-resize;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transform: translateY(-50%);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .range-handle:hover {
      border-width: 3px;
      box-shadow: 0 3px 8px rgba(0, 102, 255, 0.3);
      transform: translateY(-50%) scale(1.1);
    }

    .range-handle:active {
      background: #f0f8ff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      transform: translateY(-50%) scale(1.05);
    }

    .range-handle::before {
      content: '';
      width: 12px;
      height: 2px;
      background: #0066ff;
      position: absolute;
    }

    .range-handle::after {
      content: '';
      width: 12px;
      height: 2px;
      background: #0066ff;
      position: absolute;
      margin-top: 4px;
    }

    .range-track {
      position: absolute;
      right: 18px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(to bottom, #0066ff 0%, #e0e0e0 100%);
      border-radius: 2px;
      pointer-events: none;
    }

    .range-fill {
      position: absolute;
      right: 18px;
      bottom: 0;
      width: 2px;
      background: linear-gradient(to top, #0066ff, #0066ff40);
      transition: height 0.2s ease-out;
      pointer-events: none;
    }

    /* Bot√µes de A√ß√£o */
    .actions {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }

    .btn {
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: 400;
      border: 1px solid #000000;
      background: transparent;
      color: #000000;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: #000000;
      color: #ffffff;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: #000000;
      color: #ffffff;
    }

    .btn-primary:hover {
      background: #333333;
    }

    /* Footer com Status */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      gap: 2rem;
      opacity: 0.4;
      transition: opacity 0.3s;
      font-size: 0.85rem;
    }

    .footer:hover {
      opacity: 1;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #cccccc;
      transition: background 0.3s;
    }

    .status-indicator.active {
      background: #000000;
      animation: pulse 2s infinite;
    }

    .status-indicator.connected {
      background: #00cc00;
    }

    .status-indicator.error {
      background: #ff0000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Link para interface completa */
    .switch-interface {
      position: fixed;
      top: 1rem;
      right: 1rem;
      opacity: 0.3;
      transition: opacity 0.3s;
      font-size: 0.9rem;
    }

    .switch-interface:hover {
      opacity: 1;
    }

    .switch-interface a {
      color: #000000;
      text-decoration: none;
      padding: 0.5rem 1rem;
      border: 1px solid #000000;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .switch-interface a:hover {
      background: #000000;
      color: #ffffff;
    }

    /* Responsivo */
    @media (max-width: 768px) {
      .reading {
        font-size: 5rem;
      }

      .unit {
        font-size: 2rem;
      }

      .actions {
        flex-direction: column;
        width: 100%;
      }

      .btn {
        width: 100%;
      }
    }

    /* Loading inicial - usa a classe em vez do elemento espec√≠fico */
    .loading {
      opacity: 0.5;
      animation: fadeInOut 2s infinite;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.7; }
    }

    /* Modal de An√°lise de Sess√£o */
    .analysis-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .analysis-modal {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 90vw;
      max-height: 90vh;
      width: 900px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .analysis-modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .analysis-modal-header h2 {
      font-size: 1.5rem;
      font-weight: 400;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 2rem;
      cursor: pointer;
      color: #666;
      transition: color 0.2s;
      padding: 0;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover {
      color: #000;
    }

    .analysis-modal-content {
      flex: 1;
      padding: 1.5rem;
      display: flex;
      gap: 1.5rem;
      overflow-y: auto;
    }

    .analysis-graph-container {
      flex: 2;
      position: relative;
      background: #f9f9f9;
      border-radius: 4px;
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .analysis-graph-container canvas {
      width: 100% !important;
      height: auto !important;
    }

    .analysis-stats-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      background: #f9f9f9;
      padding: 1rem;
      border-radius: 4px;
      overflow-y: auto;
      max-height: 100%;
    }

    .stats-group {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .stats-group:last-of-type {
      border-bottom: none;
    }

    .stats-group h3 {
      font-size: 0.9rem;
      font-weight: 600;
      color: #333;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-item {
      display: flex;
      flex-direction: row;
      gap: 0.5rem;
    }

    .stat-item label {
      font-size: 0.875rem;
      color: #666;
      font-weight: 500;
    }

    .stat-item span {
      font-size: 1.1rem;
      font-weight: 300;
      color: #000;
    }

    .control-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.5rem 1rem !important;
      font-size: 0.875rem !important;
      flex: 1;
    }

    .analysis-modal-footer {
      padding: 1.5rem;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }

    .btn-secondary {
      background: #f0f0f0 !important;
      color: #000 !important;
      border: 1px solid #d0d0d0 !important;
    }

    .btn-secondary:hover {
      background: #e0e0e0 !important;
    }

    @media (max-width: 768px) {
      .analysis-modal {
        width: 95vw;
        max-height: 95vh;
      }

      .analysis-modal-content {
        flex-direction: column;
      }

      .analysis-graph-container {
        flex: 1;
      }

      .analysis-stats-panel {
        flex: 1;
      }

      .analysis-modal-footer {
        flex-direction: column;
      }

      .btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>

  <!-- Link para interface completa -->
  <div class="switch-interface">
    <a href="index.html">Interface Completa</a>
  </div>

  <!-- Container Principal -->
  <div class="container">

    <!-- Header -->
    <div class="header">
      <h1>BALAN√áA GFIG</h1>
    </div>

    <!-- Leitura Principal -->
    <div class="reading-container">
      <div class="reading" id="mainReading">
        <span id="readingValue" class="loading">---</span>
        <span class="unit" id="unitLabel" onclick="alternarUnidade()" style="cursor: pointer;" title="Clique para alternar entre N, kg e g">N</span>
        <div class="accuracy-indicator" id="accuracyIndicator" style="display: none; font-size: 0.65rem; color: #999; margin-top: 2px; text-align: center;">
          <span id="accuracyText">D√≠gitos <span style="color: #ccc;">cinza</span> = abaixo da acur√°cia</span>
        </div>
      </div>
      <div class="decimal-controls">
        <button class="decimal-btn" id="decreaseDecimal" onclick="decreaseDecimalPlaces()" title="Diminuir casas decimais">.0‚Üê</button>
        <span class="decimal-display" id="decimalDisplay">2</span>
        <button class="decimal-btn" id="increaseDecimal" onclick="increaseDecimalPlaces()" title="Aumentar casas decimais">‚Üí.0</button>
      </div>
    </div>

    <!-- Gr√°fico -->
    <div class="chart-container">
      <canvas id="minimalChart"></canvas>

      <!-- Barra de Range Vertical -->
      <div class="range-control">
        <div class="range-toggle" id="rangeToggle" onclick="toggleAutoRange()" title="Clique para alternar entre Auto e Manual">
          AUTO
        </div>
        <div class="range-scale" id="rangeScale">
          <!-- Barra de fundo -->
          <div class="range-bar"></div>
          <!-- Barra de preenchimento (at√© o valor atual) -->
          <div class="range-fill" id="rangeFill"></div>
          <!-- Indicador de valor atual -->
          <div class="range-indicator" id="rangeIndicator"></div>
          <!-- √Årea de arrasto para modo manual -->
          <div class="range-slider" id="rangeSlider">
            <!-- Track do slider -->
            <div class="range-track"></div>
            <!-- Handle arrast√°vel -->
            <div class="range-handle" id="rangeHandle"></div>
          </div>
          <!-- Ticks ser√£o inseridos dinamicamente -->
        </div>
      </div>
    </div>

    <!-- Bot√µes de A√ß√£o -->
    <div class="actions">
      <button id="record-btn" class="btn btn-primary" onclick="toggleRecording()">Iniciar Grava√ß√£o</button>
      <button class="btn" onclick="openGravacoesModal()">Grava√ß√µes</button>
      <button class="btn" onclick="executarTara()">Tara</button>
      <button class="btn" onclick="openWizardSimplificado()">Calibra√ß√£o</button>
    </div>

  </div>

  <!-- Footer com Status -->
  <div class="footer">
    <div class="status-item">
      <div class="status-indicator" id="statusConexao"></div>
      <span id="statusConexaoText">Desconectado</span>
    </div>
    <div class="status-item">
      <div class="status-indicator" id="statusBalanca"></div>
      <span id="statusBalancaText">Aguardando</span>
    </div>
    <div class="status-item">
      <span id="statusFreq">0 Hz</span>
    </div>
  </div>

  <!-- Modal de An√°lise de Sess√£o -->
  <div class="analysis-modal-overlay" id="analysisModalOverlay" style="display: none;">
    <div class="analysis-modal" id="analysisModal">
      <div class="analysis-modal-header">
        <div style="flex-grow: 1;">
            <label for="analysisSessionName" style="font-size: 0.8rem; color: #666;">Nome da Sess√£o</label>
            <input type="text" id="analysisSessionName" style="font-size: 1.4rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; width: 95%; margin-top: 4px;">
        </div>
        <button class="modal-close" id="modalCloseBtn" onclick="closeAnalysisModal()">√ó</button>
      </div>
      
      <div class="analysis-modal-content">
        <!-- Gr√°fico de an√°lise -->
        <div class="analysis-graph-container">
          <div id="analysisChart" style="width: 100%; height: 100%;"></div>
        </div>
        
        <!-- Painel de estat√≠sticas -->
        <div class="analysis-stats-panel">
          <div class="stats-group">
            <h3>Leitura Geral</h3>
            <div class="stat-item">
              <label>Valor M√≠nimo</label>
              <span id="statMin">---</span>
            </div>
            <div class="stat-item">
              <label>Valor M√°ximo</label>
              <span id="statMax">---</span>
            </div>
            <div class="stat-item">
              <label>Valor M√©dio</label>
              <span id="statAvg">---</span>
            </div>
            <div class="stat-item">
              <label>Dura√ß√£o Total</label>
              <span id="statDuration">---</span>
            </div>
          </div>

          <div class="stats-group">
            <h3>An√°lise de Queima</h3>
            <div class="stat-item">
              <label>In√≠cio Queima</label>
              <span id="burnStartTime">---</span>
            </div>
            <div class="stat-item">
              <label>Fim Queima</label>
              <span id="burnEndTime">---</span>
            </div>
            <div class="stat-item">
              <label>Tempo de Queima</label>
              <span id="burnDuration">---</span>
            </div>
            <div class="stat-item">
              <label>Impulso Total</label>
              <span id="burnImpulseTotal">---</span>
            </div>
            <div class="stat-item">
              <label>Impulso M√©dio</label>
              <span id="burnImpulseAvg">---</span>
            </div>
            <div class="stat-item">
              <label>Classifica√ß√£o NAR</label>
              <span id="motorClassification" style="font-weight: bold; padding: 4px 8px; border-radius: 4px; background-color: #95a5a6; color: white;">Indefinido</span>
            </div>
          </div>

          <div class="control-buttons">
            <button class="btn btn-small" onclick="resetBurnDetection()">Auto-Detectar</button>
          </div>
        </div>
      </div>
      
      <div class="analysis-modal-footer">
        <button class="btn btn-secondary" onclick="discardAnalysis()">Descartar</button>
        <button class="btn btn-primary" onclick="saveAnalysisSession()">Salvar Sess√£o</button>
      </div>
    </div>
  </div>

  <!-- Modal de Grava√ß√µes (Injetado via gravacoes.html) -->
  <div id="gravacoes-modal-overlay" class="gravacoes-modal-overlay">
    <div class="gravacoes-modal">
      <div class="gravacoes-modal-header">
        <h2>Grava√ß√µes Salvas</h2>
        <button class="gravacoes-modal-close" onclick="closeGravacoesModal()">√ó</button>
      </div>
      <div class="gravacoes-modal-content">
        <div id="gravacoes-lista" class="gravacoes-lista">
          <div class="gravacoes-placeholder">
            <span>Carregando grava√ß√µes...</span>
          </div>
        </div>
      </div>
      <div class="gravacoes-modal-footer">
        <span id="gravacoes-status"></span>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script>
    // ============================================================================
    // WIZARD DE CALIBRA√á√ÉO - CAMADA DE COMPATIBILIDADE
    // ============================================================================

    // Simula a interface do dataWorker que o wizard_simplificado.js espera.
    const dataWorker = {
      postMessage: (message) => {
        const { type, payload } = message;
        if (type === 'sendCommand') {
          const { cmd, value } = payload;
          const commandToSend = {};

          if (cmd === 't' || cmd === 'get_config') {
            commandToSend.cmd = cmd;
          } else if (cmd === 'c') { // Calibrate
            const mass = parseFloat(value);
            if (!isNaN(mass) && mass > 0) {
              commandToSend.cmd = 'c';
              commandToSend.massa_g = mass;
            }
          } else if (cmd === 'set') { // Set parameter
            if (value && value.param && value.value !== undefined) {
              commandToSend.cmd = 'set';
              commandToSend.param = value.param;
              commandToSend.value = value.value;
            }
          }
          
          if (commandToSend.cmd) {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(commandToSend));
            } else {
              console.error('[Bridge] WebSocket n√£o conectado. Comando n√£o enviado:', commandToSend);
            }
          }
        } else if (type === 'get_config') {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({cmd: 'get_config'}));
            }
        }
      },
      addEventListener: (type, listener) => {
        if (type === 'message') {
          window.wizardListener = listener;
        }
      },
      removeEventListener: (type, listener) => {
        if (type === 'message' && window.wizardListener === listener) {
          window.wizardListener = null;
        }
      }
    };

    // Fun√ß√£o global que o wizard usa.
    function sendCommandToWorker(command, value = null) {
      const messagePayload = { cmd: command };
      if (value !== null) {
        messagePayload.value = value;
      }
      dataWorker.postMessage({ type: 'sendCommand', payload: messagePayload });
    }

    

    // ============================================================================
    // L√ìGICA DE GRAVA√á√ÉO DE SESS√ÉO
    // ============================================================================
    let isRecording = false;
    let recordedData = [];
    let recordingStartTime = null;
    let recordingEndTime = null;
    let decimalPlaces = 2; // Controla n√∫mero de casas decimais na leitura principal

    function toggleRecording() {
        isRecording = !isRecording;
        const recordBtn = document.getElementById('record-btn');

        if (isRecording) {
            // Start recording
            recordedData = [];
            chartData = []; // Limpa o gr√°fico para a nova grava√ß√£o
            recordingStartTime = new Date();
            recordBtn.textContent = 'Parar Grava√ß√£o';
            recordBtn.style.backgroundColor = '#e74c3c';
            recordBtn.style.borderColor = '#e74c3c';
            recordBtn.style.color = '#ffffff';
            console.log('[Minimal] Grava√ß√£o iniciada.');
            showNotification('info', 'Grava√ß√£o da sess√£o iniciada.');
        } else {
            // Stop recording
            recordingEndTime = new Date();
            recordBtn.textContent = 'Iniciar Grava√ß√£o';
            recordBtn.style.backgroundColor = '';
            recordBtn.style.borderColor = '';
            recordBtn.style.color = '';
            console.log('[Minimal] Grava√ß√£o encerrada.');
            generateAndSaveSession();
        }
    }

    function generateAndSaveSession() {
        if (recordedData.length === 0) {
            showNotification('warning', 'Nenhum dado foi gravado na sess√£o.');
            return;
        }

        const formatTwoDigits = (n) => n.toString().padStart(2, '0');
        const startDate = recordingStartTime;
        const nomeSessao = `${startDate.getFullYear()}-${formatTwoDigits(startDate.getMonth() + 1)}-${formatTwoDigits(startDate.getDate())}-${formatTwoDigits(startDate.getHours())}-${formatTwoDigits(startDate.getMinutes())}-${formatTwoDigits(startDate.getSeconds())}`;

        // Prepara metadados para o modal de an√°lise
        const sessionMetadata = {
            nomeSessao: nomeSessao,
            startDate: startDate,
            recordingEndTime: recordingEndTime,
            recordedData: recordedData
        };

        // Mostra modal de an√°lise
        showAnalysisModal(recordedData, sessionMetadata);
    }

    // ============================================================================
    // MODAL DE AN√ÅLISE DE SESS√ÉO
    // ============================================================================
    let sessionDataForAnalysis = null;
    let sessionMetadataForAnalysis = null;
    let burnStartTimeAnalysis = null;
    let burnEndTimeAnalysis = null;
    let analysisChartInstance = null;

    function classificarMotor(impulsoNs) {
        // Classifica um motor baseado no seu impulso total em N¬∑s (NAR classification)
        const classificacoes = [
            { min: 0.00, max: 0.3125, classe: 'Micro 1/8A', cor: '#8e44ad' },
            { min: 0.3126, max: 0.625, classe: '¬ºA', cor: '#9b59b6' },
            { min: 0.626, max: 1.25, classe: '¬ΩA', cor: '#e74c3c' },
            { min: 1.26, max: 2.50, classe: 'A', cor: '#e67e22' },
            { min: 2.51, max: 5.00, classe: 'B', cor: '#f39c12' },
            { min: 5.01, max: 10.00, classe: 'C', cor: '#f1c40f' },
            { min: 10.01, max: 20.00, classe: 'D', cor: '#2ecc71' },
            { min: 20.01, max: 40.00, classe: 'E', cor: '#1abc9c' },
            { min: 40.01, max: 80.00, classe: 'F', cor: '#3498db' },
            { min: 80.01, max: 160.00, classe: 'G', cor: '#9b59b6' },
            { min: 160.01, max: 320.00, classe: 'H', cor: '#e74c3c' },
            { min: 320.01, max: 640.00, classe: 'I', cor: '#e67e22' },
            { min: 640.01, max: 1280.00, classe: 'J', cor: '#f39c12' },
            { min: 1280.01, max: 2560.00, classe: 'K', cor: '#2ecc71' },
            { min: 2560.01, max: 5120.00, classe: 'L', cor: '#3498db' },
            { min: 5120.01, max: 10240.00, classe: 'M', cor: '#9b59b6' },
            { min: 10240.01, max: 20480.00, classe: 'N', cor: '#e74c3c' },
            { min: 20480.01, max: 40960.00, classe: 'O', cor: '#c0392b' }
        ];

        if (impulsoNs === null || impulsoNs === undefined) {
            return { classe: 'Indefinido', cor: '#95a5a6' };
        }

        const EPS = 1e-6;
        for (let c of classificacoes) {
            if ((c.min - EPS) <= impulsoNs && impulsoNs <= (c.max + EPS)) {
                return { classe: c.classe, cor: c.cor };
            }
        }
        return { classe: 'Indefinido', cor: '#95a5a6' };
    }

    function detectBurnStart(forceValues, timeValues) {
        // Detecta o in√≠cio da queima como o primeiro ponto onde a for√ßa > 5% da m√°xima
        // Nota: timeValues j√° est√£o em segundos (n√£o em milissegundos)
        const maxForce = Math.max(...forceValues);
        const threshold = maxForce * 0.05;
        const minTime = Math.min(...timeValues);
        
        console.log('[DEBUG detectBurnStart]:', { maxForce, threshold, minTime, firstTime: timeValues[0], lastTime: timeValues[timeValues.length - 1] });

        for (let i = 0; i < forceValues.length; i++) {
            if (forceValues[i] > threshold) {
                const relativeTime = timeValues[i] - minTime; // J√° est√° em segundos, s√≥ subtrai o m√≠nimo
                console.log('[DEBUG detectBurnStart] Encontrado em:', { i, force: forceValues[i], absoluteTime: timeValues[i], relativeTime });
                return relativeTime;
            }
        }

        return 0; // Se n√£o encontrar, retorna 0s
    }

    function detectBurnEnd(forceValues, timeValues) {
        // Detecta o fim da queima como o √∫ltimo ponto onde a for√ßa > 5% da m√°xima
        // Nota: timeValues j√° est√£o em segundos (n√£o em milissegundos)
        const maxForce = Math.max(...forceValues);
        const threshold = maxForce * 0.05;
        const minTime = Math.min(...timeValues);

        for (let i = forceValues.length - 1; i >= 0; i--) {
            if (forceValues[i] > threshold) {
                const relativeTime = timeValues[i] - minTime; // J√° est√° em segundos, s√≥ subtrai o m√≠nimo
                console.log('[DEBUG detectBurnEnd] Encontrado em:', { i, force: forceValues[i], absoluteTime: timeValues[i], relativeTime });
                return relativeTime;
            }
        }

        const relativeTime = timeValues[timeValues.length - 1] - minTime; // Se n√£o encontrar, retorna √∫ltimo tempo
        console.log('[DEBUG detectBurnEnd] Usando √∫ltimo ponto:', { relativeTime });
        return relativeTime;
    }

    function calculateBurnMetrics(forceValues, timeValues, startTime, endTime) {
        // startTime e endTime s√£o em segundos (tempo relativo)
        // timeValues tamb√©m j√° est√£o em segundos
        const minTime = Math.min(...timeValues);
        const startTimeAbs = startTime + minTime;
        const endTimeAbs = endTime + minTime;

        // Calcula impulso total e m√©dio usando regra do trap√©zio
        let impulsoTotal = 0;
        let countPoints = 0;

        for (let i = 0; i < timeValues.length; i++) {
            if (i > 0) {
                const tPrev = timeValues[i - 1];
                const tCur = timeValues[i];
                
                if (tCur >= startTimeAbs && tPrev >= startTimeAbs && tCur <= endTimeAbs) {
                    const dt = tCur - tPrev; // J√° est√° em segundos
                    const f1 = forceValues[i - 1];
                    const f2 = forceValues[i];
                    const areaTrap = dt * (f1 + f2) / 2;
                    if (areaTrap > 0) {
                        impulsoTotal += areaTrap;
                        countPoints++;
                    }
                }
            }
        }

        const impulsoMedio = countPoints > 0 ? impulsoTotal / (endTime - startTime) : 0;
        const duracao = endTime - startTime;

        return {
            impulsoTotal: impulsoTotal,
            impulsoMedio: impulsoMedio,
            duracao: duracao
        };
    }

    function resetBurnDetection() {
        if (!sessionDataForAnalysis) return;

        const forceValues = sessionDataForAnalysis.map(d => d.forca);
        const timeValues = sessionDataForAnalysis.map(d => d.tempo);

        burnStartTimeAnalysis = detectBurnStart(forceValues, timeValues);
        burnEndTimeAnalysis = detectBurnEnd(forceValues, timeValues);

        renderAnalysisGraph();
        updateAnalysisStats();
    }


    function showAnalysisModal(sessionData, sessionMetadata) {
        sessionDataForAnalysis = sessionData;
        sessionMetadataForAnalysis = sessionMetadata;

        const overlay = document.getElementById('analysisModalOverlay');
        overlay.style.display = 'flex';

        // Popula o nome da sess√£o no novo input
        document.getElementById('analysisSessionName').value = sessionMetadata.nomeSessao;

        // Detecta automaticamente in√≠cio e fim da queima
        const forceValues = sessionData.map(d => d.forca);
        const timeValues = sessionData.map(d => d.tempo);
        
        console.log('[DEBUG] Dados da sess√£o:');
        console.log('  - Total de pontos:', sessionData.length);
        console.log('  - Tempo do primeiro ponto:', timeValues[0], 'ms');
        console.log('  - Tempo do √∫ltimo ponto:', timeValues[timeValues.length - 1], 'ms');
        console.log('  - Diferen√ßa:', timeValues[timeValues.length - 1] - timeValues[0], 'ms');
        
        burnStartTimeAnalysis = detectBurnStart(forceValues, timeValues);
        burnEndTimeAnalysis = detectBurnEnd(forceValues, timeValues);
        
        console.log('[DEBUG] Tempos detectados:');
        console.log('  - In√≠cio da queima:', burnStartTimeAnalysis, 's');
        console.log('  - Fim da queima:', burnEndTimeAnalysis, 's');

        // Renderizar gr√°fico e estat√≠sticas
        setTimeout(() => {
            renderAnalysisGraph();
            updateAnalysisStats();
        }, 100);
    }

    function closeAnalysisModal() {
        const overlay = document.getElementById('analysisModalOverlay');
        overlay.style.display = 'none';
        sessionDataForAnalysis = null;
        sessionMetadataForAnalysis = null;
        burnStartTimeAnalysis = null;
        burnEndTimeAnalysis = null;
        // Limpa dados da grava√ß√£o anterior
        recordedData = [];
        if (chartData.length > MAX_CHART_POINTS) {
            chartData = chartData.slice(chartData.length - MAX_CHART_POINTS);
        }
    }

    function renderAnalysisGraph() {
        if (!sessionDataForAnalysis || sessionDataForAnalysis.length === 0) {
            console.warn('Nenhum dado para renderizar no gr√°fico de an√°lise');
            return;
        }

        // Dest√≥i gr√°fico anterior se existir
        if (analysisChartInstance) {
            analysisChartInstance.destroy();
            analysisChartInstance = null;
        }

        const forceValues = sessionDataForAnalysis.map(d => d.forca);
        const timeValues = sessionDataForAnalysis.map(d => d.tempo);
        const minTime = Math.min(...timeValues);

        // Converte tempos para relativo (0 = in√≠cio da grava√ß√£o)
        // Nota: timeValues j√° est√£o em segundos, s√≥ precisa subtrair o m√≠nimo
        const relativeTimeValues = timeValues.map(t => t - minTime); // em segundos

        // Prepara dados para ApexCharts
        const chartData = relativeTimeValues.map((t, i) => ({
            x: t,
            y: forceValues[i]
        }));

        // burnStartTimeAnalysis e burnEndTimeAnalysis j√° est√£o em tempo relativo (segundos)
        const startRelative = burnStartTimeAnalysis;
        const endRelative = burnEndTimeAnalysis;

        // Cria √°rea de queima
        const burnAreaData = relativeTimeValues.map((t, i) => ({
            x: t,
            y: (t >= startRelative && t <= endRelative) ? forceValues[i] : null
        }));

        const options = {
            series: [
                {
                    name: 'For√ßa (N)',
                    type: 'line',
                    data: chartData
                },
                {
                    name: 'Queima',
                    type: 'area',
                    data: burnAreaData
                }
            ],
            chart: {
                type: 'line',
                height: 400,
                animations: {
                    enabled: false
                },
                toolbar: {
                    show: true,
                    tools: {
                        download: true,
                        selection: false,
                        zoom: true,
                        zoomin: true,
                        zoomout: true,
                        pan: true,
                        reset: true
                    },
                    autoSelected: 'pan'
                },
                events: {
                    click: function(event, chartContext, config) {
                        // Permite clicar no gr√°fico para ajustar pontos de queima
                        if (config.dataPointIndex !== undefined && config.dataPointIndex >= 0) {
                            const clickedTime = chartData[config.dataPointIndex].x; // Tempo relativo em segundos

                            // Determina se est√° mais pr√≥ximo do in√≠cio ou fim
                            const distStart = Math.abs(clickedTime - burnStartTimeAnalysis);
                            const distEnd = Math.abs(clickedTime - burnEndTimeAnalysis);

                            if (distStart < distEnd) {
                                burnStartTimeAnalysis = clickedTime; // Mant√©m em tempo relativo
                            } else {
                                burnEndTimeAnalysis = clickedTime; // Mant√©m em tempo relativo
                            }

                            renderAnalysisGraph();
                            updateAnalysisStats();
                        }
                    }
                }
            },
            responsive: [
                {
                    breakpoint: 768,
                    options: {
                        chart: {
                            height: 350
                        },
                        xaxis: {
                            labels: {
                                style: {
                                    fontSize: '11px'
                                }
                            }
                        },
                        yaxis: {
                            labels: {
                                style: {
                                    fontSize: '11px'
                                }
                            }
                        }
                    }
                },
                {
                    breakpoint: 480,
                    options: {
                        chart: {
                            height: 300
                        },
                        xaxis: {
                            labels: {
                                style: {
                                    fontSize: '10px'
                                }
                            }
                        },
                        yaxis: {
                            labels: {
                                style: {
                                    fontSize: '10px'
                                }
                            }
                        }
                    }
                }
            ],
            stroke: {
                curve: 'smooth',
                width: [2, 0]
            },
            fill: {
                type: ['solid', 'solid'],
                opacity: [1, 0.3]
            },
            colors: ['#3498db', '#2ecc71'],
            xaxis: {
                type: 'numeric',
                title: {
                    text: 'Tempo Relativo (s)'
                },
                decimalsInFloat: 3
            },
            yaxis: {
                title: {
                    text: 'For√ßa (N)'
                },
                decimalsInFloat: 2
            },
            annotations: {
                xaxis: [
                    {
                        x: startRelative,
                        borderColor: '#00E396',
                        label: {
                            borderColor: '#00E396',
                            style: { color: '#fff', background: '#00E396' },
                            text: 'üî• In√≠cio'
                        }
                    },
                    {
                        x: endRelative,
                        borderColor: '#FEB019',
                        label: {
                            borderColor: '#FEB019',
                            style: { color: '#fff', background: '#FEB019' },
                            text: 'üèÅ Fim'
                        }
                    }
                ]
            },
            grid: {
                borderColor: '#e7e7e7',
                row: {
                    colors: ['#f3f3f3', 'transparent'],
                    opacity: 0.5
                }
            }
        };

        const chartContainer = document.getElementById('analysisChart');
        analysisChartInstance = new ApexCharts(chartContainer, options);
        analysisChartInstance.render();
    }

    function updateAnalysisStats() {
        if (!sessionDataForAnalysis || sessionDataForAnalysis.length === 0) {
            return;
        }

        const forceValues = sessionDataForAnalysis.map(d => d.forca);
        const timeValues = sessionDataForAnalysis.map(d => d.tempo);
        const minForce = Math.min(...forceValues);
        const maxForce = Math.max(...forceValues);
        const avgForce = forceValues.reduce((a, b) => a + b, 0) / forceValues.length;

        // Calcula dura√ß√£o em segundos
        const firstTime = sessionDataForAnalysis[0].tempo;
        const lastTime = sessionDataForAnalysis[sessionDataForAnalysis.length - 1].tempo;
        const duration = (lastTime - firstTime).toFixed(2); // J√° est√° em segundos, n√£o divide por 1000

        // Obt√©m unidade atual
        const unitLabel = document.getElementById('unitLabel').textContent;
        const precision = unitLabel === 'N' ? 1 : (unitLabel === 'kg' ? 2 : 1);

        // Converte para unidade atual
        const convertValue = (forceN) => {
            if (unitLabel === 'N') return forceN;
            if (unitLabel === 'kg') return forceN / 9.80665;
            if (unitLabel === 'g') return (forceN / 9.80665) * 1000;
            return forceN;
        };

        const minConverted = convertValue(minForce).toLocaleString('pt-BR', { minimumFractionDigits: precision, maximumFractionDigits: precision });
        const maxConverted = convertValue(maxForce).toLocaleString('pt-BR', { minimumFractionDigits: precision, maximumFractionDigits: precision });
        const avgConverted = convertValue(avgForce).toLocaleString('pt-BR', { minimumFractionDigits: precision, maximumFractionDigits: precision });
        const durationFormatted = (duration).replace('.', ',');

        // Atualiza elementos gerais
        document.getElementById('statMin').textContent = `${minConverted} ${unitLabel}`;
        document.getElementById('statMax').textContent = `${maxConverted} ${unitLabel}`;
        document.getElementById('statAvg').textContent = `${avgConverted} ${unitLabel}`;
        document.getElementById('statDuration').textContent = `${durationFormatted} s`;

        // Calcula m√©tricas de queima
        if (burnStartTimeAnalysis !== null && burnEndTimeAnalysis !== null) {
            const burnMetrics = calculateBurnMetrics(forceValues, timeValues, burnStartTimeAnalysis, burnEndTimeAnalysis);
            
            // Formata n√∫meros em pt-BR (v√≠rgula como separador decimal) - 5 casas decimais
            const formatPtBR = (num) => num.toLocaleString('pt-BR', { minimumFractionDigits: 5, maximumFractionDigits: 5 });
            
            document.getElementById('burnStartTime').textContent = formatPtBR(burnStartTimeAnalysis);
            document.getElementById('burnEndTime').textContent = formatPtBR(burnEndTimeAnalysis);
            document.getElementById('burnDuration').textContent = formatPtBR(burnMetrics.duracao);
            document.getElementById('burnImpulseTotal').textContent = `${formatPtBR(burnMetrics.impulsoTotal)} N¬∑s`;
            document.getElementById('burnImpulseAvg').textContent = `${formatPtBR(burnMetrics.impulsoMedio)} N/s`;
            
            // Classifica o motor conforme NAR
            const classification = classificarMotor(burnMetrics.impulsoTotal);
            const motorClassEl = document.getElementById('motorClassification');
            motorClassEl.textContent = classification.classe;
            motorClassEl.style.backgroundColor = classification.cor;
        }
    }

    function discardAnalysis() {
        closeAnalysisModal();
        // Reseta para a pr√≥xima grava√ß√£o
        recordedData = [];
        if (chartData.length > MAX_CHART_POINTS) {
            chartData = chartData.slice(chartData.length - MAX_CHART_POINTS);
        }
        showNotification('info', 'Sess√£o descartada.');
    }

    function saveAnalysisSession() {
        if (!sessionMetadataForAnalysis) {
            console.error('Metadados da sess√£o n√£o encontrados');
            return;
        }

        // Pega o nome da sess√£o do input
        const nomeSessao = document.getElementById('analysisSessionName').value.trim();
        if (!nomeSessao) {
            showNotification('error', 'O nome da sess√£o n√£o pode estar vazio.');
            return;
        }

        // Extrai dados do metadata
        const { startDate, recordingEndTime, recordedData: data } = sessionMetadataForAnalysis;

        const formatTwoDigits = (n) => n.toString().padStart(2, '0');
        const sessionStartTimeForData = data[0].tempo;

        const dadosTabela = data.map(d => {
            const tempoNormalizado = (d.tempo - sessionStartTimeForData);
            const forcaN = d.forca;
            const g_force = forcaN / 9.80665;

            const agora = new Date(startDate.getTime() + (tempoNormalizado * 1000));
            const dd = String(agora.getUTCDate()).padStart(2, '0');
            const mm = String(agora.getUTCMonth() + 1).padStart(2, '0');
            const yyyy = agora.getUTCFullYear();
            const HH = String(agora.getUTCHours()).padStart(2, '0');
            const MM = String(agora.getUTCMinutes()).padStart(2, '0');
            const SS = String(agora.getUTCSeconds()).padStart(2, '0');
            const mmm = String(agora.getUTCMilliseconds()).padStart(3, '0');
            const timestamp = `${dd}/${mm}/${yyyy} ${HH}:${MM}:${SS}.${mmm}`;

            return {
                timestamp: timestamp,
                tempo_esp: tempoNormalizado.toFixed(3),
                newtons: forcaN.toFixed(6),
                grama_forca: (g_force * 1000).toFixed(3),
                quilo_forca: g_force.toFixed(6)
            };
        });

        const gravacao = {
            id: startDate.getTime(),
            nome: nomeSessao, // Usa o nome do input
            timestamp: startDate.toISOString(),
            data_inicio: startDate.toISOString(),
            data_fim: recordingEndTime.toISOString(),
            data_modificacao: new Date().toISOString(),
            dadosTabela: dadosTabela,
            metadadosMotor: {},
            savedToMysql: false
        };

        try {
            let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
            gravacoes.push(gravacao);
            localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
            showNotification('success', `Sess√£o "${nomeSessao}" salva localmente!`);
            console.log('[Minimal] Sess√£o salva localmente:', gravacao);

            // Tenta salvar no banco de dados se o WebSocket estiver conectado
            if (ws && ws.readyState === WebSocket.OPEN) {
                const command = {
                    cmd: "save_session_to_mysql",
                    payload: gravacao
                };
                ws.send(JSON.stringify(command));
                showNotification('info', `Enviando sess√£o "${nomeSessao}" para o banco de dados...`);
                console.log('[Minimal] Enviando sess√£o para o DB via WebSocket.');
            } else {
                showNotification('warning', 'Sess√£o salva localmente. Conex√£o com o servidor inativa para salvar no DB.');
            }

        } catch (e) {
            showNotification('error', 'Erro ao salvar sess√£o no LocalStorage.');
            console.error('[Minimal] Erro ao salvar sess√£o:', e);
        }

        closeAnalysisModal();
        recordedData = [];
        if (chartData.length > MAX_CHART_POINTS) {
            chartData = chartData.slice(chartData.length - MAX_CHART_POINTS);
        }
    }


    // ============================================================================
    // CONFIGURA√á√ÉO E VARI√ÅVEIS GLOBAIS (Originais)
    // ============================================================================

    let chart = null;
    let chartData = [];
    const MAX_CHART_POINTS = 100;
    let lastUpdateTime = 0;
    let updateCount = 0;
    let frequencyHz = 0;

    // Conex√£o WebSocket e dados
    let ws = null;
    let wsReconnectInterval = null;
    let isConnected = false;

    // Unidade de medida
    let unidadeAtual = 'N'; // 'N' (Newtons), 'kg', 'g'
    const coresUnidades = {
      'N': '#0066ff',   // Azul para Newtons
      'kg': '#000000',  // Preto para kg
      'g': '#00cc66'    // Verde para gramas
    };

    // Controle de Range
    let autoRange = true;
    let manualRangeMax = 100; // Valor m√°ximo manual em N
    let capacidadeMaxN = 500; // Capacidade da c√©lula em N (ser√° atualizada)
    let erroMinN = 1; // Erro m√≠nimo da c√©lula em N (ser√° atualizado pela acur√°cia)
    let isDragging = false;

    // ============================================================================
    // INICIALIZA√á√ÉO
    // ============================================================================

    window.addEventListener('DOMContentLoaded', () => {
      console.log('[Minimal] üöÄ P√°gina carregada');
      inicializarGrafico();

      // Inicializa controle de range
      document.getElementById('rangeToggle').classList.add('active');
      document.getElementById('rangeIndicator').classList.add('auto-mode');
      inicializarRangeSlider();

      // Conecta ao WebSocket automaticamente
      conectarWebSocket();
    });

    // ============================================================================
    // GR√ÅFICO MINIMALISTA
    // ============================================================================

    function inicializarGrafico() {
      const canvas = document.getElementById('minimalChart');
      const ctx = canvas.getContext('2d');

      // Configura tamanho do canvas
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      chart = {
        canvas,
        ctx,
        width: rect.width,
        height: rect.height
      };

      // Renderiza gr√°fico vazio
      renderizarGrafico();
    }

    function renderizarGrafico() {
      if (!chart) return;

      const { ctx, width, height } = chart;

      // Limpa canvas
      ctx.clearRect(0, 0, width, height);

      if (chartData.length === 0) {
        // Mensagem de aguardando dados
        ctx.fillStyle = '#cccccc';
        ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Aguardando dados...', width / 2, height / 2);
        return;
      }

      // Calcula min/max baseado no modo de range
      const valores = chartData.map(d => d.valor);
      let minVal, maxVal;

      if (autoRange) {
        // Modo AUTO: usa valores reais dos dados
        minVal = Math.min(...valores, 0);
        maxVal = Math.max(...valores);
        maxVal = Math.max(maxVal * 1.2, 10); // 20% margem, m√≠nimo 10N
      } else {
        // Modo MANUAL: usa o range definido pelo usu√°rio
        minVal = 0;
        maxVal = manualRangeMax;
      }

      const range = maxVal - minVal || 1;
      const margin = 40;
      const plotWidth = width - margin * 2;
      const plotHeight = height - margin * 2;

      // Cor baseada na unidade atual
      const cor = coresUnidades[unidadeAtual];

      // === 1. GRID SUTIL COM ESCALAS ===
      ctx.strokeStyle = '#d0d0d0';
      ctx.lineWidth = 1;

      // Linhas horizontais com labels de escala (10 linhas)
      for (let i = 0; i <= 10; i++) {
        const y = margin + (plotHeight / 10) * i;
        
        // Desenha linha
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(width - margin - 35, y); // Deixa espa√ßo menor para os labels
        ctx.stroke();
        
        // Calcula valor correspondente a esta linha
        const valorNaLinha = maxVal - (maxVal - minVal) * (i / 10);
        
        // Converte para unidade atual
        let valorDisplay, labelText;
        switch (unidadeAtual) {
          case 'kg':
            valorDisplay = (valorNaLinha / 9.80665).toFixed(2);
            labelText = `${valorDisplay} kg`;
            break;
          case 'g':
            valorDisplay = (valorNaLinha / 9.80665 * 1000).toFixed(1);
            labelText = `${valorDisplay} g`;
            break;
          case 'N':
          default:
            valorDisplay = valorNaLinha.toFixed(1);
            labelText = `${valorDisplay} N`;
            break;
        }
        
        // Desenha label do lado direito
        ctx.fillStyle = '#666666';
        ctx.font = '24px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.fillText(labelText, width - margin + 20, y);
      }

      // === 2. DESENHA LINHA PRINCIPAL ===
      ctx.strokeStyle = cor;
      ctx.lineWidth = 2.5;
      ctx.shadowColor = cor;
      ctx.shadowBlur = 4;
      ctx.beginPath();

      // Durante grava√ß√£o: usa o tamanho real dos dados
      // Fora da grava√ß√£o: usa MAX_CHART_POINTS para manter escala consistente
      let effectiveMax = isRecording ? chartData.length : MAX_CHART_POINTS;
      const x_denominator = Math.max(effectiveMax - 1, 1);

      chartData.forEach((d, i) => {
        const x = margin + (i / x_denominator) * plotWidth;
        const y = margin + plotHeight - ((d.valor - minVal) / range) * plotHeight;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();
      ctx.shadowBlur = 0;

      // === 3. PONTO ATUAL (√∫ltimo valor) ===
      if (chartData.length > 0) {
        const last = chartData[chartData.length - 1];
        const lastX = margin + ((chartData.length - 1) / x_denominator) * plotWidth;
        const lastY = margin + plotHeight - ((last.valor - minVal) / range) * plotHeight;

        // C√≠rculo externo (halo)
        ctx.beginPath();
        ctx.arc(lastX, lastY, 6, 0, Math.PI * 2);
        ctx.fillStyle = cor + '40';
        ctx.fill();

        // C√≠rculo interno
        ctx.beginPath();
        ctx.arc(lastX, lastY, 3, 0, Math.PI * 2);
        ctx.fillStyle = cor;
        ctx.fill();
      }

      // === 4. LINHA DE ZERO (se vis√≠vel) ===
      if (minVal < 0 && maxVal > 0) {
        const zeroY = margin + plotHeight - ((0 - minVal) / range) * plotHeight;
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(margin, zeroY);
        ctx.lineTo(width - margin, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Atualiza escala de range
      atualizarRangeScale();
    }

    // ============================================================================
    // CONEX√ÉO WEBSOCKET E LEITURA DE DADOS
    // ============================================================================

    // Solicita configura√ß√µes da c√©lula com retry autom√°tico
    function solicitarConfiguracao() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify({cmd: 'get_config'}));
          console.log('[Minimal] üìã Configura√ß√£o da c√©lula solicitada');
          return true;
        } catch (e) {
          console.warn('[Minimal] Erro ao solicitar configura√ß√£o:', e);
          return false;
        }
      }
      return false;
    }

    function conectarWebSocket() {
      try {
        console.log('[Minimal] üîå Conectando ao WebSocket...');

        // Constr√≥i URL do WebSocket (porta 81, como a interface principal)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const hostname = window.location.hostname;

        // Usa porta 81 (servidor Python WebSocket)
        const wsUrl = `${protocol}//${hostname}:81`;

        console.log('[Minimal] üì° URL do WebSocket:', wsUrl);

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log('[Minimal] ‚úÖ WebSocket conectado!');
          isConnected = true;
          atualizarStatusConexao(true);

          // Limpa tentativas de reconex√£o
          if (wsReconnectInterval) {
            clearInterval(wsReconnectInterval);
            wsReconnectInterval = null;
          }

          // Solicita configura√ß√µes da c√©lula de forma ass√≠ncrona com pequeno delay
          console.log('[Minimal] üìã Solicitando configura√ß√µes da c√©lula em background...');
          setTimeout(() => {
            solicitarConfiguracao();
          }, 100);

          // Tenta solicitar novamente ap√≥s 500ms se ainda n√£o temos os dados
          setTimeout(() => {
            if (capacidadeMaxN === 500) { // Valor padr√£o, significa que n√£o recebemos config
              console.log('[Minimal] üîÑ Reenviando solicita√ß√£o de configura√ß√£o...');
              solicitarConfiguracao();
            }
          }, 500);
        };

        ws.onmessage = (event) => {
          try {
            const dados = JSON.parse(event.data);
            processarMensagemWS(dados);
          } catch (e) {
            console.warn('[Minimal] Erro ao parsear mensagem WS:', e);
          }
        };

        ws.onerror = (error) => {
          console.error('[Minimal] ‚ùå Erro no WebSocket:', error);
        };

        ws.onclose = () => {
          console.log('[Minimal] ‚ö†Ô∏è WebSocket desconectado');
          isConnected = false;
          atualizarStatusConexao(false);

          // Tenta reconectar a cada 3 segundos
          if (!wsReconnectInterval) {
            wsReconnectInterval = setInterval(() => {
              console.log('[Minimal] üîÑ Tentando reconectar...');
              conectarWebSocket();
            }, 3000);
          }
        };

      } catch (error) {
        console.error('[Minimal] ‚ùå Erro ao criar WebSocket:', error);
        atualizarStatusConexao(false);
      }
    }

    function processarMensagemWS(dados) {
      // --- BRIDGE PARA O WIZARD ---
      if (window.wizardListener) {
        let wizardPayload;
        if (dados.type === 'data') {
          // O wizard espera um array de dados
          wizardPayload = { type: 'dadosDisponiveis', payload: [dados] };
        } else if (dados.type === 'config') {
          wizardPayload = { type: 'config', payload: dados };
        }
        if (wizardPayload) {
          window.wizardListener({ data: wizardPayload });
        }
      }
      // --- FIM DA BRIDGE ---

      // Mensagem pode conter um ou mais pacotes de dados
      if (dados.type === 'data') {
        // Dados em tempo real
        processarDado({
          forca: dados.forca || 0,
          tempo: dados.tempo,
          status: dados.status || 0,
          raw: dados.raw || 0
        });
      } else if (dados.type === 'batch' && Array.isArray(dados.data)) {
        // Batch de dados (v√°rios pacotes de uma vez)
        dados.data.forEach(d => {
          processarDado({
            forca: d.forca || 0,
            tempo: d.tempo,
            status: d.status || 0,
            raw: d.raw || 0
          });
        });
      } else if (dados.type === 'config') {
        // Configura√ß√µes da c√©lula de carga
        if (dados.capacidadeMaximaGramas) {
          capacidadeMaxN = (dados.capacidadeMaximaGramas / 1000) * 9.80665; // g ‚Üí kg ‚Üí N
        }
        if (dados.percentualAcuracia) {
          // Calcula erro m√≠nimo baseado na acur√°cia
          erroMinN = capacidadeMaxN * dados.percentualAcuracia;
        }
        console.log(`[Minimal] Config atualizada: Cap=${capacidadeMaxN.toFixed(1)}N, Erro=${erroMinN.toFixed(3)}N`);
      } else if (dados.type === 'serial_status') { // Corrected type and payload
        // Handle serial status updates
        if (typeof handleSerialStatusUpdate === 'function') {
          handleSerialStatusUpdate(dados); // Pass the entire 'dados' object as payload
        }
      }
    }

    function processarDado(dado) {
      if (typeof dado.tempo === 'undefined') return; // Ignora pacotes sem timestamp

      if (isRecording) {
        recordedData.push(dado);
      }
      // Atualiza leitura principal
      atualizarLeituraPrincipal(dado.forca);

      // Adiciona ao gr√°fico
      chartData.push({
        valor: dado.forca,
        tempo: dado.tempo
      });

      // Limita tamanho do array somente se n√£o estiver gravando
      if (!isRecording && chartData.length > MAX_CHART_POINTS) {
        chartData.shift();
      }

      // Renderiza gr√°fico
      renderizarGrafico();

      // Calcula frequ√™ncia
      updateCount++;
      const now = Date.now();
      if (now - lastUpdateTime >= 1000) {
        frequencyHz = updateCount;
        document.getElementById('statusFreq').textContent = `${frequencyHz} Hz`;
        updateCount = 0;
        lastUpdateTime = now;
      }

      // Mapeia c√≥digo de status para string
      const statusMap = {
        0: 'Pesando',
        1: 'Tarar',
        2: 'Calibrar',
        3: 'Pronta'
      };

      const statusTexto = statusMap[dado.status] || 'Pesando';
      atualizarStatusBalanca(statusTexto);
    }

    function atualizarLeituraPrincipal(valorN) {
        const readingEl = document.getElementById('readingValue');
        const readingContainerEl = document.querySelector('.reading-container');
        const accuracyIndicatorEl = document.getElementById('accuracyIndicator');
        const mainReadingEl = document.getElementById('mainReading');

        let valorConvertido, precisaoBase;
        let erroConvertido = 0;

        switch (unidadeAtual) {
          case 'kg':
            valorConvertido = valorN / 9.80665;
            // erroMinN est√° em N, converter para kg
            erroConvertido = (erroMinN || 0) / 9.80665;
            precisaoBase = 3;
            break;
          case 'g':
            valorConvertido = (valorN / 9.80665) * 1000;
            // erroMinN est√° em N, converter para g
            erroConvertido = ((erroMinN || 0) / 9.80665) * 1000;
            precisaoBase = 3;
            break;
          case 'N':
          default:
            valorConvertido = valorN;
            // erroMinN j√° est√° em N
            erroConvertido = erroMinN || 0;
            precisaoBase = 2;
            break;
        }

        // Usa o n√∫mero de casas decimais definido pelo usu√°rio
        const precisao = decimalPlaces !== undefined ? decimalPlaces : precisaoBase;
        const valorArredondado = parseFloat(valorConvertido.toFixed(precisao));
        const valorFormatado = valorArredondado.toFixed(precisao).replace('.', ',');

        // Calcula a precis√£o confi√°vel: encontra a √∫ltima casa decimal onde 10^(-i) > erro
        let casasConfiaveis = -1; // -1 significa que at√© a unidade √© afetada
        if (erroConvertido > 0) {
            for (let i = 0; i <= precisao; i++) {
                const magnitude = Math.pow(10, -i);
                if (magnitude > erroConvertido) {
                    casasConfiaveis = i;
                } else {
                    break;
                }
            }
        }

        // Formata a string com d√≠gitos confi√°veis e n√£o confi√°veis
        let htmlFormatado = '';
        const partes = valorFormatado.split(',');
        const parteInteira = partes[0];
        const parteDecimal = partes[1] || '';

        // Parte inteira (sempre confi√°vel)
        htmlFormatado += `<span class="digit-reliable">${parteInteira}</span>`;

        // Parte decimal
        if (parteDecimal.length > 0) {
            htmlFormatado += `,`;
            for (let i = 0; i < parteDecimal.length; i++) {
                if (i < casasConfiaveis) {
                    htmlFormatado += `<span class="digit-reliable">${parteDecimal[i]}</span>`;
                } else {
                    htmlFormatado += `<span class="digit-unreliable">${parteDecimal[i]}</span>`;
                }
            }
        }

        readingEl.innerHTML = htmlFormatado;

        // Aplica a cor da unidade atual ao elemento .reading
        const corUnidade = coresUnidades[unidadeAtual] || '#000000';
        mainReadingEl.style.color = corUnidade;

        // Atualiza a cor da leitura principal
        if (valorN < 0) {
            readingEl.classList.add('negative');
            readingEl.classList.remove('positive');
        } else {
            readingEl.classList.add('positive');
            readingEl.classList.remove('negative');
        }

        // Mostra/esconde o indicador de acur√°cia
        if (casasConfiaveis < precisao) {
            accuracyIndicatorEl.style.display = 'block';
            const unreliableDigits = precisao - casasConfiaveis;
            accuracyIndicatorEl.querySelector('span').textContent = `D√≠gitos ${unreliableDigits > 0 ? unreliableDigits : ''} cinza = abaixo da acur√°cia`;
        } else {
            accuracyIndicatorEl.style.display = 'none';
        }
    }

    function alternarUnidade() {
        const unitLabel = document.getElementById('unitLabel');
        if (unidadeAtual === 'N') {
            unidadeAtual = 'kg';
        } else if (unidadeAtual === 'kg') {
            unidadeAtual = 'g';
        } else {
            unidadeAtual = 'N';
        }
        unitLabel.textContent = unidadeAtual;
        // For√ßa uma atualiza√ß√£o da leitura principal para recalcular e exibir na nova unidade
        // Usa o √∫ltimo valor conhecido de for√ßa em N
        atualizarLeituraPrincipal(chartData.length > 0 ? chartData[chartData.length - 1].valor : 0);
        renderizarGrafico(); // Redesenha o gr√°fico com a nova unidade
    }

    function increaseDecimalPlaces() {
        if (decimalPlaces < 5) { // Limite m√°ximo de casas decimais
            decimalPlaces++;
            document.getElementById('decimalDisplay').textContent = decimalPlaces;
            atualizarLeituraPrincipal(chartData.length > 0 ? chartData[chartData.length - 1].valor : 0);
        }
    }

    function decreaseDecimalPlaces() {
        if (decimalPlaces > 0) { // Limite m√≠nimo de casas decimais
            decimalPlaces--;
            document.getElementById('decimalDisplay').textContent = decimalPlaces;
            atualizarLeituraPrincipal(chartData.length > 0 ? chartData[chartData.length - 1].valor : 0);
        }
    }

    // ============================================================================
    // STATUS DA CONEX√ÉO E BALAN√áA
    // ============================================================================

    function atualizarStatusConexao(conectado) {
      const statusConexao = document.getElementById('statusConexao');
      const statusConexaoText = document.getElementById('statusConexaoText');
      if (conectado) {
        statusConexao.classList.remove('error');
        statusConexao.classList.add('connected');
        statusConexaoText.textContent = 'Conectado';
      } else {
        statusConexao.classList.remove('connected');
        statusConexao.classList.add('error');
        statusConexaoText.textContent = 'Desconectado';
      }
    }

    function atualizarStatusBalanca(status) {
      const statusBalanca = document.getElementById('statusBalanca');
      const statusBalancaText = document.getElementById('statusBalancaText');
      statusBalancaText.textContent = status;
      if (status === 'Pronta' || status === 'Pesando') {
        statusBalanca.classList.remove('error');
        statusBalanca.classList.add('active');
      } else {
        statusBalanca.classList.remove('active');
        statusBalanca.classList.add('error');
      }
    }

    // ============================================================================
    // CONTROLE DE RANGE DO GR√ÅFICO
    // ============================================================================

    function toggleAutoRange() {
      autoRange = !autoRange;
      const rangeToggle = document.getElementById('rangeToggle');
      const rangeIndicator = document.getElementById('rangeIndicator');
      const rangeSlider = document.getElementById('rangeSlider');

      if (autoRange) {
        rangeToggle.classList.add('active');
        rangeToggle.textContent = 'AUTO';
        rangeIndicator.classList.add('auto-mode');
        rangeSlider.style.display = 'none';
      } else {
        rangeToggle.classList.remove('active');
        rangeToggle.textContent = 'MANUAL';
        rangeIndicator.classList.remove('auto-mode');
        rangeSlider.style.display = 'block';
        // Define o manualRangeMax para o valor atual do indicador ao mudar para manual
        manualRangeMax = parseFloat(rangeIndicator.dataset.value);
      }
      renderizarGrafico();
      atualizarRangeScale();
    }

    function inicializarRangeSlider() {
      const rangeSlider = document.getElementById('rangeSlider');
      const rangeHandle = document.getElementById('rangeHandle');
      const rangeScale = document.getElementById('rangeScale');

      let startY, startTop, maxTop, minTop;

      rangeHandle.addEventListener('mousedown', (e) => {
        if (autoRange) return; // N√£o permite arrastar em modo auto
        isDragging = true;
        startY = e.clientY;
        startTop = rangeHandle.offsetTop;

        const scaleRect = rangeScale.getBoundingClientRect();
        minTop = 0;
        maxTop = scaleRect.height;

        rangeHandle.style.cursor = 'ns-resize';
        document.body.style.userSelect = 'none'; // Previne sele√ß√£o de texto
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        if (autoRange) return;

        const dy = e.clientY - startY;
        let newTop = startTop + dy;

        // Limita o movimento do handle dentro da escala
        newTop = Math.max(minTop, Math.min(newTop, maxTop));

        rangeHandle.style.top = `${newTop}px`;

        // Calcula o novo valor de manualRangeMax
        const percent = 1 - (newTop / maxTop); // 0% no topo, 100% na base
        manualRangeMax = Math.max(1, capacidadeMaxN * percent); // M√≠nimo de 1N

        atualizarRangeScale();
        renderizarGrafico();
      });

      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          rangeHandle.style.cursor = 'grab';
          document.body.style.userSelect = '';
        }
      });

      // Inicializa a posi√ß√£o do handle e o valor do indicador
      atualizarRangeScale();
    }

    function atualizarRangeScale() {
      const rangeScale = document.getElementById('rangeScale');
      const rangeIndicator = document.getElementById('rangeIndicator');
      const rangeHandle = document.getElementById('rangeHandle');
      const rangeFill = document.getElementById('rangeFill');

      // Limpa ticks antigos
      rangeScale.querySelectorAll('.range-tick').forEach(tick => tick.remove());

      const scaleHeight = rangeScale.clientHeight;
      const currentMax = autoRange ? Math.max(...chartData.map(d => d.valor), 10) : manualRangeMax;
      const currentVal = chartData.length > 0 ? chartData[chartData.length - 1].valor : 0;

      // Atualiza a posi√ß√£o do indicador de valor atual
      const indicatorPercent = Math.min(1, Math.max(0, currentVal / currentMax));
      const indicatorTop = scaleHeight * (1 - indicatorPercent);
      rangeIndicator.style.top = `${indicatorTop}px`;
      rangeIndicator.dataset.value = currentMax; // Armazena o valor m√°ximo atual

      // Atualiza a altura do preenchimento
      rangeFill.style.height = `${scaleHeight - indicatorTop}px`;
      rangeFill.style.top = `${indicatorTop}px`;

      // Atualiza a posi√ß√£o do handle do slider (se em modo manual)
      if (!autoRange) {
        const handlePercent = manualRangeMax / capacidadeMaxN;
        const handleTop = scaleHeight * (1 - handlePercent);
        rangeHandle.style.top = `${handleTop}px`;
        rangeSlider.style.display = 'block';
      } else {
        rangeSlider.style.display = 'none';
      }

      // Adiciona ticks de escala (ex: 0%, 25%, 50%, 75%, 100%)
      for (let i = 0; i <= 4; i++) {
        const tickPercent = i * 0.25; // 0, 0.25, 0.5, 0.75, 1
        const tickY = scaleHeight * (1 - tickPercent);
        const tickValueN = currentMax * tickPercent;

        const tickEl = document.createElement('div');
        tickEl.className = 'range-tick';
        tickEl.style.top = `${tickY}px`;
        tickEl.innerHTML = `
          <span class="range-tick-value">${tickValueN.toFixed(0)}N</span>
          <div class="range-tick-line"></div>
        `;
        rangeScale.appendChild(tickEl);
      }
    }

    // ============================================================================
    // FUN√á√ïES DE CALIBRA√á√ÉO E TARA (COMPATIBILIDADE COM WIZARD)
    // ============================================================================

    function executarTara() {
      sendCommandToWorker('t');
      showNotification('info', 'Comando de Tara enviado.');
    }

    function openWizardSimplificado() {
      // Esta fun√ß√£o √© um placeholder para o wizard_simplificado.js
      // que ser√° carregado e ter√° sua pr√≥pria implementa√ß√£o de openWizardSimplificado
      if (typeof window.openWizardSimplificado === 'function') {
        window.openWizardSimplificado();
      } else {
        showNotification('warning', 'O assistente de calibra√ß√£o n√£o foi carregado.');
      }
    }

  </script>
  <!-- Modal de Grava√ß√µes j√° est√° inclu√≠do inline acima -->
</body>
</html>