<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Balan√ßa GFIG - Modo Minimalista</title>
  <link rel="stylesheet" href="estilo.css">
  <script src="wizard_simplificado.js" defer></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      background: #ffffff;
      color: #000000;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Container Principal */
    .container {
      width: 100%;
      max-width: 900px;
      padding: 2rem;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3rem;
    }

    /* Logo/T√≠tulo */
    .header {
      opacity: 0.6;
      transition: opacity 0.3s;
    }

    .header:hover {
      opacity: 1;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.5px;
    }

    /* Leitura Principal */
    .reading-container {
      position: relative;
    }

    .reading {
      font-size: 8rem;
      font-weight: 200;
      line-height: 1;
      letter-spacing: -0.02em;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      color: #000000;
    }

    .reading.positive {
      color: #000000;
    }

    .reading.negative {
      color: #888888;
    }

    .unit {
      font-size: 3rem;
      font-weight: 300;
      margin-left: 0.5rem;
      opacity: 0.7;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
    }

    .unit:hover {
      opacity: 1;
      transform: scale(1.05);
    }

    .unit:active {
      transform: scale(0.95);
    }

    /* Transi√ß√µes suaves para mudan√ßa de cor */
    #readingValue {
      transition: color 0.4s ease-in-out;
    }

    /* Gr√°fico */
    .chart-container {
      width: 100vw;
      height: 45vh;
      position: relative;
      margin-top: 1.5rem;
      margin-left: calc(-50vw + 50%);
      display: flex;
    }

    #minimalChart {
      flex: 1;
      height: 100%;
    }

    /* Barra de Range Vertical */
    .range-control {
      width: 80px;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 0;
      background: rgba(255, 255, 255, 0.5);
      border-left: 1px solid #f0f0f0;
    }

    .range-toggle {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
      transition: color 0.2s;
      text-align: center;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .range-toggle:hover {
      color: #000;
      background: rgba(0, 0, 0, 0.05);
    }

    .range-toggle.active {
      color: #0066ff;
      font-weight: 500;
    }

    .range-scale {
      flex: 1;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 0 10px;
      position: relative;
    }

    .range-tick {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      position: relative;
    }

    .range-tick-line {
      width: 8px;
      height: 1px;
      background: #ccc;
      margin-left: 4px;
    }

    .range-tick-value {
      font-size: 0.65rem;
      color: #666;
      min-width: 40px;
      text-align: right;
    }

    .range-bar {
      position: absolute;
      right: 18px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #f0f0f0;
    }

    .range-indicator {
      position: absolute;
      right: 16px;
      width: 6px;
      height: 6px;
      background: #0066ff;
      border-radius: 50%;
      transform: translateY(-50%);
      transition: top 0.2s ease-out, width 0.3s, height 0.3s, right 0.3s;
    }

    .range-indicator.auto-mode {
      width: 10px;
      height: 10px;
      right: 14px;
      box-shadow: 0 0 8px rgba(0, 102, 255, 0.5);
    }

    .range-slider {
      position: absolute;
      right: 10px;
      top: 0;
      bottom: 0;
      width: 30px;
      cursor: pointer;
    }

    .range-handle {
      position: absolute;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #ffffff;
      border: 2px solid #0066ff;
      border-radius: 4px;
      cursor: ns-resize;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transform: translateY(-50%);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .range-handle:hover {
      border-width: 3px;
      box-shadow: 0 3px 8px rgba(0, 102, 255, 0.3);
      transform: translateY(-50%) scale(1.1);
    }

    .range-handle:active {
      background: #f0f8ff;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      transform: translateY(-50%) scale(1.05);
    }

    .range-handle::before {
      content: '';
      width: 12px;
      height: 2px;
      background: #0066ff;
      position: absolute;
    }

    .range-handle::after {
      content: '';
      width: 12px;
      height: 2px;
      background: #0066ff;
      position: absolute;
      margin-top: 4px;
    }

    .range-track {
      position: absolute;
      right: 18px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(to bottom, #0066ff 0%, #e0e0e0 100%);
      border-radius: 2px;
      pointer-events: none;
    }

    .range-fill {
      position: absolute;
      right: 18px;
      bottom: 0;
      width: 2px;
      background: linear-gradient(to top, #0066ff, #0066ff40);
      transition: height 0.2s ease-out;
      pointer-events: none;
    }

    /* Bot√µes de A√ß√£o */
    .actions {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }

    .btn {
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: 400;
      border: 1px solid #000000;
      background: transparent;
      color: #000000;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
      letter-spacing: 0.5px;
    }

    .btn:hover {
      background: #000000;
      color: #ffffff;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: #000000;
      color: #ffffff;
    }

    .btn-primary:hover {
      background: #333333;
    }

    /* Footer com Status */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      gap: 2rem;
      opacity: 0.4;
      transition: opacity 0.3s;
      font-size: 0.85rem;
    }

    .footer:hover {
      opacity: 1;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #cccccc;
      transition: background 0.3s;
    }

    .status-indicator.active {
      background: #000000;
      animation: pulse 2s infinite;
    }

    .status-indicator.connected {
      background: #00cc00;
    }

    .status-indicator.error {
      background: #ff0000;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Link para interface completa */
    .switch-interface {
      position: fixed;
      top: 1rem;
      right: 1rem;
      opacity: 0.3;
      transition: opacity 0.3s;
      font-size: 0.9rem;
    }

    .switch-interface:hover {
      opacity: 1;
    }

    .switch-interface a {
      color: #000000;
      text-decoration: none;
      padding: 0.5rem 1rem;
      border: 1px solid #000000;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .switch-interface a:hover {
      background: #000000;
      color: #ffffff;
    }

    /* Responsivo */
    @media (max-width: 768px) {
      .reading {
        font-size: 5rem;
      }

      .unit {
        font-size: 2rem;
      }

      .actions {
        flex-direction: column;
        width: 100%;
      }

      .btn {
        width: 100%;
      }
    }

    /* Loading inicial */
    .loading {
      font-size: 1rem;
      opacity: 0.5;
      animation: fadeInOut 2s infinite;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.7; }
    }
  </style>
</head>
<body>

  <!-- Link para interface completa -->
  <div class="switch-interface">
    <a href="index.html">Interface Completa</a>
  </div>

  <!-- Container Principal -->
  <div class="container">

    <!-- Header -->
    <div class="header">
      <h1>BALAN√áA GFIG</h1>
    </div>

    <!-- Leitura Principal -->
    <div class="reading-container">
      <div class="reading" id="mainReading">
        <span id="readingValue" class="loading">---</span>
        <span class="unit" id="unitLabel" onclick="alternarUnidade()" style="cursor: pointer;" title="Clique para alternar entre N, kg e g">N</span>
      </div>
    </div>

    <!-- Gr√°fico -->
    <div class="chart-container">
      <canvas id="minimalChart"></canvas>

      <!-- Barra de Range Vertical -->
      <div class="range-control">
        <div class="range-toggle" id="rangeToggle" onclick="toggleAutoRange()" title="Clique para alternar entre Auto e Manual">
          AUTO
        </div>
        <div class="range-scale" id="rangeScale">
          <!-- Barra de fundo -->
          <div class="range-bar"></div>
          <!-- Barra de preenchimento (at√© o valor atual) -->
          <div class="range-fill" id="rangeFill"></div>
          <!-- Indicador de valor atual -->
          <div class="range-indicator" id="rangeIndicator"></div>
          <!-- √Årea de arrasto para modo manual -->
          <div class="range-slider" id="rangeSlider">
            <!-- Track do slider -->
            <div class="range-track"></div>
            <!-- Handle arrast√°vel -->
            <div class="range-handle" id="rangeHandle"></div>
          </div>
          <!-- Ticks ser√£o inseridos dinamicamente -->
        </div>
      </div>
    </div>

    <!-- Bot√µes de A√ß√£o -->
    <div class="actions">
      <button class="btn btn-primary" onclick="iniciarNovaSessao()">Iniciar Nova Sess√£o</button>
      <button class="btn" onclick="openWizardSimplificado()">Calibra√ß√£o</button>
    </div>

  </div>

  <!-- Footer com Status -->
  <div class="footer">
    <div class="status-item">
      <div class="status-indicator" id="statusConexao"></div>
      <span id="statusConexaoText">Desconectado</span>
    </div>
    <div class="status-item">
      <div class="status-indicator" id="statusBalanca"></div>
      <span id="statusBalancaText">Aguardando</span>
    </div>
    <div class="status-item">
      <span id="statusFreq">0 Hz</span>
    </div>
  </div>

  <!-- Scripts -->
  <script>
    // ============================================================================
    // WIZARD DE CALIBRA√á√ÉO - CAMADA DE COMPATIBILIDADE
    // ============================================================================

    // Simula a interface do dataWorker que o wizard_simplificado.js espera.
    const dataWorker = {
      postMessage: (message) => {
        const { type, payload } = message;
        if (type === 'sendCommand') {
          const { cmd, value } = payload;
          const commandToSend = {};

          if (cmd === 't' || cmd === 'get_config') {
            commandToSend.cmd = cmd;
          } else if (cmd === 'c') { // Calibrate
            const mass = parseFloat(value);
            if (!isNaN(mass) && mass > 0) {
              commandToSend.cmd = 'c';
              commandToSend.massa_g = mass;
            }
          } else if (cmd === 'set') { // Set parameter
            if (value && value.param && value.value !== undefined) {
              commandToSend.cmd = 'set';
              commandToSend.param = value.param;
              commandToSend.value = value.value;
            }
          }
          
          if (commandToSend.cmd) {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(commandToSend));
            } else {
              console.error('[Bridge] WebSocket n√£o conectado. Comando n√£o enviado:', commandToSend);
            }
          }
        } else if (type === 'get_config') {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({cmd: 'get_config'}));
            }
        }
      },
      addEventListener: (type, listener) => {
        if (type === 'message') {
          window.wizardListener = listener;
        }
      },
      removeEventListener: (type, listener) => {
        if (type === 'message' && window.wizardListener === listener) {
          window.wizardListener = null;
        }
      }
    };

    // Fun√ß√£o global que o wizard usa.
    function sendCommandToWorker(command, value = null) {
      const messagePayload = { cmd: command };
      if (value !== null) {
        messagePayload.value = value;
      }
      dataWorker.postMessage({ type: 'sendCommand', payload: messagePayload });
    }

    // Fun√ß√£o de notifica√ß√£o que o wizard precisa.
    function showNotification(type, message, duration = 5000) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            transform: translateX(100%);
        `;
        notification.style.backgroundColor = type === 'error' ? '#e74c3c' : (type === 'success' ? '#2ecc71' : '#3498db');
        notification.innerHTML = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(0)';
        }, 10);

        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => notification.remove(), 500);
        }, duration);
    }

    // ============================================================================
    // CONFIGURA√á√ÉO E VARI√ÅVEIS GLOBAIS
    // ============================================================================

    let chart = null;
    let chartData = [];
    const MAX_CHART_POINTS = 100;
    let lastUpdateTime = 0;
    let updateCount = 0;
    let frequencyHz = 0;

    // Conex√£o WebSocket e dados
    let ws = null;
    let wsReconnectInterval = null;
    let isConnected = false;

    // Unidade de medida
    let unidadeAtual = 'N'; // 'N' (Newtons), 'kg', 'g'
    const coresUnidades = {
      'N': '#0066ff',   // Azul para Newtons
      'kg': '#000000',  // Preto para kg
      'g': '#00cc66'    // Verde para gramas
    };

    // Controle de Range
    let autoRange = true;
    let manualRangeMax = 100; // Valor m√°ximo manual em N
    let capacidadeMaxN = 500; // Capacidade da c√©lula em N (ser√° atualizada)
    let erroMinN = 1; // Erro m√≠nimo da c√©lula em N (ser√° atualizado pela acur√°cia)
    let isDragging = false;

    // ============================================================================
    // INICIALIZA√á√ÉO
    // ============================================================================

    window.addEventListener('DOMContentLoaded', () => {
      console.log('[Minimal] üöÄ P√°gina carregada');
      inicializarGrafico();

      // Inicializa controle de range
      document.getElementById('rangeToggle').classList.add('active');
      document.getElementById('rangeIndicator').classList.add('auto-mode');
      inicializarRangeSlider();

      // Conecta ao WebSocket automaticamente
      conectarWebSocket();
    });

    // ============================================================================
    // GR√ÅFICO MINIMALISTA
    // ============================================================================

    function inicializarGrafico() {
      const canvas = document.getElementById('minimalChart');
      const ctx = canvas.getContext('2d');

      // Configura tamanho do canvas
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      chart = {
        canvas,
        ctx,
        width: rect.width,
        height: rect.height
      };

      // Renderiza gr√°fico vazio
      renderizarGrafico();
    }

    function renderizarGrafico() {
      if (!chart) return;

      const { ctx, width, height } = chart;

      // Limpa canvas
      ctx.clearRect(0, 0, width, height);

      if (chartData.length === 0) {
        // Mensagem de aguardando dados
        ctx.fillStyle = '#cccccc';
        ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Aguardando dados...', width / 2, height / 2);
        return;
      }

      // Calcula min/max baseado no modo de range
      const valores = chartData.map(d => d.valor);
      let minVal, maxVal;

      if (autoRange) {
        // Modo AUTO: usa valores reais dos dados
        minVal = Math.min(...valores, 0);
        maxVal = Math.max(...valores);
        maxVal = Math.max(maxVal * 1.2, 10); // 20% margem, m√≠nimo 10N
      } else {
        // Modo MANUAL: usa o range definido pelo usu√°rio
        minVal = 0;
        maxVal = manualRangeMax;
      }

      const range = maxVal - minVal || 1;
      const margin = 20;
      const plotWidth = width - margin * 2;
      const plotHeight = height - margin * 2;

      // Cor baseada na unidade atual
      const cor = coresUnidades[unidadeAtual];

      // === 1. GRID SUTIL ===
      ctx.strokeStyle = '#d0d0d0';
      ctx.lineWidth = 1;

      // Linhas horizontais
      for (let i = 0; i <= 4; i++) {
        const y = margin + (plotHeight / 4) * i;
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(width - margin, y);
        ctx.stroke();
      }

      // === 2. DESENHA LINHA PRINCIPAL ===
      ctx.strokeStyle = cor;
      ctx.lineWidth = 2.5;
      ctx.shadowColor = cor;
      ctx.shadowBlur = 4;
      ctx.beginPath();

      chartData.forEach((d, i) => {
        const x = margin + (i / (MAX_CHART_POINTS - 1)) * plotWidth;
        const y = margin + plotHeight - ((d.valor - minVal) / range) * plotHeight;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();
      ctx.shadowBlur = 0;

      // === 3. PONTO ATUAL (√∫ltimo valor) ===
      if (chartData.length > 0) {
        const last = chartData[chartData.length - 1];
        const lastX = margin + ((chartData.length - 1) / (MAX_CHART_POINTS - 1)) * plotWidth;
        const lastY = margin + plotHeight - ((last.valor - minVal) / range) * plotHeight;

        // C√≠rculo externo (halo)
        ctx.beginPath();
        ctx.arc(lastX, lastY, 6, 0, Math.PI * 2);
        ctx.fillStyle = cor + '40';
        ctx.fill();

        // C√≠rculo interno
        ctx.beginPath();
        ctx.arc(lastX, lastY, 3, 0, Math.PI * 2);
        ctx.fillStyle = cor;
        ctx.fill();
      }

      // === 4. LINHA DE ZERO (se vis√≠vel) ===
      if (minVal < 0 && maxVal > 0) {
        const zeroY = margin + plotHeight - ((0 - minVal) / range) * plotHeight;
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(margin, zeroY);
        ctx.lineTo(width - margin, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Atualiza escala de range
      atualizarRangeScale();
    }

    // ============================================================================
    // CONEX√ÉO WEBSOCKET E LEITURA DE DADOS
    // ============================================================================

    function conectarWebSocket() {
      try {
        console.log('[Minimal] üîå Conectando ao WebSocket...');

        // Constr√≥i URL do WebSocket (porta 81, como a interface principal)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const hostname = window.location.hostname;

        // Usa porta 81 (servidor Python WebSocket)
        const wsUrl = `${protocol}//${hostname}:81`;

        console.log('[Minimal] üì° URL do WebSocket:', wsUrl);

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log('[Minimal] ‚úÖ WebSocket conectado!');
          isConnected = true;
          atualizarStatusConexao(true);

          // Limpa tentativas de reconex√£o
          if (wsReconnectInterval) {
            clearInterval(wsReconnectInterval);
            wsReconnectInterval = null;
          }
        };

        ws.onmessage = (event) => {
          try {
            const dados = JSON.parse(event.data);
            processarMensagemWS(dados);
          } catch (e) {
            console.warn('[Minimal] Erro ao parsear mensagem WS:', e);
          }
        };

        ws.onerror = (error) => {
          console.error('[Minimal] ‚ùå Erro no WebSocket:', error);
        };

        ws.onclose = () => {
          console.log('[Minimal] ‚ö†Ô∏è WebSocket desconectado');
          isConnected = false;
          atualizarStatusConexao(false);

          // Tenta reconectar a cada 3 segundos
          if (!wsReconnectInterval) {
            wsReconnectInterval = setInterval(() => {
              console.log('[Minimal] üîÑ Tentando reconectar...');
              conectarWebSocket();
            }, 3000);
          }
        };

      } catch (error) {
        console.error('[Minimal] ‚ùå Erro ao criar WebSocket:', error);
        atualizarStatusConexao(false);
      }
    }

    function processarMensagemWS(dados) {
      // --- BRIDGE PARA O WIZARD ---
      if (window.wizardListener) {
        let wizardPayload;
        if (dados.type === 'data') {
          // O wizard espera um array de dados
          wizardPayload = { type: 'dadosDisponiveis', payload: [dados] };
        } else if (dados.type === 'config') {
          wizardPayload = { type: 'config', payload: dados };
        }
        if (wizardPayload) {
          window.wizardListener({ data: wizardPayload });
        }
      }
      // --- FIM DA BRIDGE ---

      // Mensagem pode conter um ou mais pacotes de dados
      if (dados.type === 'data') {
        // Dados em tempo real
        processarDado({
          forca: dados.forca || 0,
          timestamp: dados.timestamp || Date.now(),
          status: dados.status || 0,
          raw: dados.raw || 0
        });
      } else if (dados.type === 'batch' && Array.isArray(dados.data)) {
        // Batch de dados (v√°rios pacotes de uma vez)
        dados.data.forEach(d => {
          processarDado({
            forca: d.forca || 0,
            timestamp: d.timestamp || Date.now(),
            status: d.status || 0,
            raw: d.raw || 0
          });
        });
      } else if (dados.type === 'config') {
        // Configura√ß√µes da c√©lula de carga
        if (dados.capacidadeMaximaGramas) {
          capacidadeMaxN = (dados.capacidadeMaximaGramas / 1000) * 9.80665; // g ‚Üí kg ‚Üí N
        }
        if (dados.percentualAcuracia) {
          // Calcula erro m√≠nimo baseado na acur√°cia
          erroMinN = capacidadeMaxN * dados.percentualAcuracia;
        }
        console.log(`[Minimal] Config atualizada: Cap=${capacidadeMaxN.toFixed(1)}N, Erro=${erroMinN.toFixed(3)}N`);
      }
    }

    function processarDado(dado) {
      // Atualiza leitura principal
      atualizarLeituraPrincipal(dado.forca);

      // Adiciona ao gr√°fico
      chartData.push({
        valor: dado.forca,
        timestamp: Date.now()
      });

      // Limita tamanho do array
      if (chartData.length > MAX_CHART_POINTS) {
        chartData.shift();
      }

      // Renderiza gr√°fico
      renderizarGrafico();

      // Calcula frequ√™ncia
      updateCount++;
      const now = Date.now();
      if (now - lastUpdateTime >= 1000) {
        frequencyHz = updateCount;
        document.getElementById('statusFreq').textContent = `${frequencyHz} Hz`;
        updateCount = 0;
        lastUpdateTime = now;
      }

      // Mapeia c√≥digo de status para string
      const statusMap = {
        0: 'Pesando',
        1: 'Tarar',
        2: 'Calibrar',
        3: 'Pronta'
      };

      const statusTexto = statusMap[dado.status] || 'Pesando';
      atualizarStatusBalanca(statusTexto);
    }

    function atualizarLeituraPrincipal(valorN) {
      const readingEl = document.getElementById('readingValue');
      const mainReadingEl = document.getElementById('mainReading');

      // Converte para unidade selecionada
      let valorConvertido, precisao;

      switch (unidadeAtual) {
        case 'kg':
          valorConvertido = valorN / 9.80665;  // N ‚Üí kg
          precisao = 3;
          break;
        case 'g':
          valorConvertido = (valorN / 9.80665) * 1000;  // N ‚Üí kg ‚Üí g
          precisao = 1;
          break;
        case 'N':
        default:
          valorConvertido = valorN;
          precisao = 2;
          break;
      }

      // Formata valor
      const valorFormatado = Math.abs(valorConvertido).toFixed(precisao);

      // Atualiza texto
      readingEl.textContent = valorFormatado;
      readingEl.classList.remove('loading');

      // Atualiza cor baseado na unidade
      const cor = coresUnidades[unidadeAtual];
      readingEl.style.color = cor;
      document.getElementById('unitLabel').style.color = cor;

      // Mant√©m cor de sinal (opcional, pode remover se quiser s√≥ cor de unidade)
      if (valorConvertido >= 0) {
        mainReadingEl.classList.add('positive');
        mainReadingEl.classList.remove('negative');
      } else {
        mainReadingEl.classList.add('negative');
        mainReadingEl.classList.remove('positive');
      }
    }

    function alternarUnidade() {
      // Ciclo: N ‚Üí kg ‚Üí g ‚Üí N
      const unidades = ['N', 'kg', 'g'];
      const indexAtual = unidades.indexOf(unidadeAtual);
      const proximoIndex = (indexAtual + 1) % unidades.length;

      unidadeAtual = unidades[proximoIndex];

      // Atualiza label
      document.getElementById('unitLabel').textContent = unidadeAtual;

      // Atualiza cor
      const cor = coresUnidades[unidadeAtual];
      document.getElementById('readingValue').style.color = cor;
      document.getElementById('unitLabel').style.color = cor;

      console.log(`[Minimal] Unidade alterada para: ${unidadeAtual}`);

      // Efeito visual de feedback (pulso)
      const unitLabel = document.getElementById('unitLabel');
      const readingValue = document.getElementById('readingValue');

      // Pulso na unidade
      unitLabel.style.transform = 'scale(1.3)';
      setTimeout(() => {
        unitLabel.style.transform = 'scale(1)';
      }, 200);

      // Flash sutil no valor
      readingValue.style.opacity = '0.7';
      setTimeout(() => {
        readingValue.style.opacity = '1';
      }, 150);

      // Atualiza escala de range com nova unidade
      atualizarRangeScale();
    }

    // ============================================================================
    // CONTROLE DE RANGE
    // ============================================================================

    function toggleAutoRange() {
      autoRange = !autoRange;
      const toggle = document.getElementById('rangeToggle');
      const indicator = document.getElementById('rangeIndicator');
      const slider = document.getElementById('rangeSlider');

      if (autoRange) {
        toggle.textContent = 'AUTO';
        toggle.classList.add('active');
        indicator.classList.add('auto-mode');
        slider.style.display = 'none';
        toggle.title = 'Clique para alternar para Manual';
      } else {
        toggle.textContent = 'MANUAL';
        toggle.classList.remove('active');
        indicator.classList.remove('auto-mode');
        slider.style.display = 'block';
        // Inicializa range manual com o valor atual do auto
        if (chartData.length > 0) {
          const valores = chartData.map(d => d.valor);
          manualRangeMax = Math.max(...valores, 10) * 1.2;
        }

        // Posiciona handle inicialmente no meio (50% da capacidade)
        const scaleEl = document.getElementById('rangeScale');
        const handle = document.getElementById('rangeHandle');
        if (scaleEl && handle) {
          const percent = (manualRangeMax - erroMinN) / (capacidadeMaxN - erroMinN);
          const y = scaleEl.offsetHeight * (1 - percent);
          handle.style.top = `${y}px`;
        }

        const erroKg = (erroMinN / 9.80665).toFixed(3);
        const capKg = (capacidadeMaxN / 9.80665).toFixed(1);
        toggle.title = `Arraste verticalmente: ${erroKg}kg - ${capKg}kg`;
      }

      renderizarGrafico();
    }

    function inicializarRangeSlider() {
      const slider = document.getElementById('rangeSlider');
      const handle = document.getElementById('rangeHandle');
      const scaleEl = document.getElementById('rangeScale');

      slider.style.display = 'none'; // Oculto inicialmente (modo AUTO)

      // Mouse events no handle
      handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (!autoRange) {
          isDragging = true;
          document.body.style.cursor = 'ns-resize';
        }
      });

      // Mouse events no slider (clique direto na track)
      slider.addEventListener('mousedown', (e) => {
        if (!autoRange && e.target !== handle) {
          isDragging = true;
          handleRangeDrag(e, scaleEl);
          document.body.style.cursor = 'ns-resize';
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging && !autoRange) {
          handleRangeDrag(e, scaleEl);
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.cursor = '';
      });

      // Touch events para mobile
      handle.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        if (!autoRange) {
          isDragging = true;
        }
      });

      slider.addEventListener('touchstart', (e) => {
        if (!autoRange && e.target !== handle) {
          isDragging = true;
          handleRangeDrag(e.touches[0], scaleEl);
        }
      });

      document.addEventListener('touchmove', (e) => {
        if (isDragging && !autoRange) {
          e.preventDefault();
          handleRangeDrag(e.touches[0], scaleEl);
        }
      }, { passive: false });

      document.addEventListener('touchend', () => {
        isDragging = false;
      });
    }

    function handleRangeDrag(e, scaleEl) {
      const rect = scaleEl.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const percent = 1 - (y / rect.height); // Inverte para bottom-up
      const clampedPercent = Math.max(0, Math.min(1, percent)); // 0% a 100%

      // Interpola entre erro m√≠nimo e capacidade m√°xima
      // 0% = erroMinN, 100% = capacidadeMaxN
      manualRangeMax = erroMinN + (capacidadeMaxN - erroMinN) * clampedPercent;

      // Atualiza posi√ß√£o do handle
      const handle = document.getElementById('rangeHandle');
      if (handle) {
        handle.style.top = `${y}px`;
      }

      // For√ßa atualiza√ß√£o imediata do gr√°fico e escala
      renderizarGrafico();
    }

    function atualizarRangeScale() {
      const scaleEl = document.getElementById('rangeScale');
      if (!scaleEl) return; // Ainda n√£o inicializado

      const indicatorEl = document.getElementById('rangeIndicator');

      // Determina o range m√°ximo
      let maxVal;
      if (autoRange) {
        if (chartData.length > 0) {
          const valores = chartData.map(d => d.valor);
          maxVal = Math.max(...valores, 10); // M√≠nimo de 10N para escala vis√≠vel
          maxVal = maxVal * 1.2; // 20% margem
        } else {
          maxVal = capacidadeMaxN;
        }
      } else {
        // Modo manual - usa o valor ajustado pelo usu√°rio
        maxVal = manualRangeMax;
      }

      // Cria 5 ticks (0, 25%, 50%, 75%, 100%)
      const numTicks = 5;
      let ticksHTML = '';

      for (let i = 0; i < numTicks; i++) {
        const percent = (numTicks - 1 - i) / (numTicks - 1); // Inverte para come√ßar do topo
        const valorN = maxVal * percent;

        // Converte para unidade atual
        let valorDisplay, unidade;
        switch (unidadeAtual) {
          case 'kg':
            valorDisplay = (valorN / 9.80665).toFixed(1);
            unidade = 'kg';
            break;
          case 'g':
            valorDisplay = (valorN / 9.80665 * 1000).toFixed(0);
            unidade = 'g';
            break;
          case 'N':
          default:
            valorDisplay = valorN.toFixed(0);
            unidade = 'N';
            break;
        }

        ticksHTML += `
          <div class="range-tick">
            <span class="range-tick-value">${valorDisplay}</span>
            <div class="range-tick-line"></div>
          </div>
        `;
      }

      // Preserva barra, preenchimento, indicador e slider
      const bar = scaleEl.querySelector('.range-bar');
      const fill = scaleEl.querySelector('.range-fill');
      const indicator = scaleEl.querySelector('.range-indicator');
      const slider = scaleEl.querySelector('.range-slider');
      scaleEl.innerHTML = ticksHTML;
      scaleEl.appendChild(bar);
      scaleEl.appendChild(fill);
      scaleEl.appendChild(indicator);
      scaleEl.appendChild(slider);

      // Atualiza posi√ß√£o do indicador e barra de preenchimento com o valor atual
      if (chartData.length > 0) {
        const valorAtual = chartData[chartData.length - 1].valor;
        const percent = Math.min(Math.max(valorAtual / maxVal, 0), 1);
        const scaleHeight = scaleEl.offsetHeight;
        const topPos = scaleHeight * (1 - percent); // Inverte para bottom-up

        indicator.style.top = `${topPos}px`;
        indicator.style.background = coresUnidades[unidadeAtual];

        // Atualiza barra de preenchimento
        fill.style.height = `${percent * 100}%`;
        fill.style.background = `linear-gradient(to top, ${coresUnidades[unidadeAtual]}, ${coresUnidades[unidadeAtual]}40)`;
      }
    }

    function atualizarStatusConexao(conectado) {
      const indicator = document.getElementById('statusConexao');
      const text = document.getElementById('statusConexaoText');

      if (conectado) {
        indicator.classList.add('connected');
        indicator.classList.remove('error');
        text.textContent = 'Conectado';
      } else {
        indicator.classList.remove('connected');
        indicator.classList.add('error');
        text.textContent = 'Desconectado';
      }
    }

    function atualizarStatusBalanca(status) {
      const indicator = document.getElementById('statusBalanca');
      const text = document.getElementById('statusBalancaText');

      text.textContent = status;

      if (status === 'Pesando') {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }

    // ============================================================================
    // A√á√ïES DOS BOT√ïES
    // ============================================================================

    function iniciarNovaSessao() {
      // Redireciona para interface completa com sess√£o
      window.location.href = 'index.html?action=nova_sessao';
    }

    // ============================================================================
    // REDIMENSIONAMENTO
    // ============================================================================

    window.addEventListener('resize', () => {
      if (chart) {
        inicializarGrafico();
      }
    });

  </script>
</body>
</html>

</body>
</html>
